from typing import Any, Callable, Dict, Iterator, List, Optional, cast

from bs4 import BeautifulSoup, Tag
from bs4.element import NavigableString


class XHTMLParser:
    """A class to convert Confluence XHTML into structured, clean plain text.

    This utility is designed to parse the specific XHTML format generated by
    Confluence, intelligently handling elements like macros, tables, and lists
    to produce a semantically structured text output suitable for language models
    and vector databases.
    """

    def __init__(self, xhtml_content: str) -> None:
        """Initializes the cleaner with the XHTML content.

        Args:
            xhtml_content: A string containing the Confluence XHTML.
        """
        self.soup: BeautifulSoup = BeautifulSoup(xhtml_content, 'html.parser')

    def text(self) -> str:
        """Executes the full conversion process from XHTML to plain text.

        Returns:
            A single string of cleaned and structured plain text.
        """
        # We process the body tag, or the root of the soup if no body exists.
        root_element: Any = self.soup.find('body') or self.soup

        # Process all direct children of the root element recursively
        text_parts: List[str] = [part for part in self._process_children(root_element) if part]

        # Join parts and clean up excessive whitespace
        return '\n'.join(text_parts).strip()

    def _process_children(self, element: Any) -> Iterator[str]:
        """Iterates over and processes the children of a given BeautifulSoup Tag or PageElement."""
        if not hasattr(element, 'children'):
            return
        for child in element.children:
            yield self._process_element(child)

    def _process_element(self, element: Any) -> str:
        """Recursively processes a BeautifulSoup element and converts it to text.

        This is the core dispatcher that routes elements to the appropriate
        handler based on their type (Tag or NavigableString) and name.

        Args:
            element: The BeautifulSoup element to process.

        Returns:
            The processed text representation of the element.
        """
        if isinstance(element, NavigableString):
            # For strings, we just return them, stripped of whitespace.
            # We add a space to prevent words from mashing together.
            return str(element).strip()

        if not isinstance(element, Tag):
            return ''

        # Dispatch to the correct handler based on the tag name
        handler_map: Dict[str, Callable[[Tag], str]] = {
            'p': self._handle_paragraph,
            'h1': self._handle_heading,
            'h2': self._handle_heading,
            'h3': self._handle_heading,
            'h4': self._handle_heading,
            'h5': self._handle_heading,
            'h6': self._handle_heading,
            'ul': self._handle_list,
            'ol': self._handle_list,
            'li': self._handle_list_item,
            'table': self._handle_table,
            'ac:structured-macro': self._handle_macro,
            'ac:plain-text-body': lambda e: self._get_inner_text(e, ' '),
        }

        handler: Optional[Callable[[Tag], str]] = handler_map.get(element.name, None)

        if handler is not None:
            return handler(element)

        # Default fallback for unknown tags: process their children
        return self._get_inner_text(element, ' ')

    def _get_inner_text(self, element: Tag, separator: str = '') -> str:
        """Processes child elements and joins their output with smart trimming."""
        parts: List[str] = []

        for child in element.children:
            if isinstance(child, (Tag, NavigableString)):
                text = self._process_element(child).strip()
                if text:
                    parts.append(text)

        result = separator.join(parts)

        # Optionally clean up spaces before punctuation
        return result.replace(' .', '.').replace(' ,', ',').replace(' !', '!').replace(' ?', '?')

    def _handle_paragraph(self, element: Tag) -> str:
        """Handles <p> tags."""
        return f'{self._get_inner_text(element, " ")}\n'

    def _handle_heading(self, element: Tag) -> str:
        """Handles <h1>, <h2>, etc. tags."""
        try:
            level: int = int(element.name[1])
        except (IndexError, ValueError, TypeError):
            level = 1
        text: str = self._get_inner_text(element, ' ')
        return f'\n{"#" * level} {text}\n'

    def _handle_list(self, element: Tag) -> str:
        """Handles <ul> and <ol> tags by processing their list items."""
        return self._get_inner_text(element, '')

    def _handle_list_item(self, element: Tag) -> str:
        """Handles <li> tags, adding a markdown-style prefix."""
        # Check parent to determine if it's an ordered or unordered list
        is_ordered: bool = element.find_parent('ol') is not None
        prefix: str = '1. ' if is_ordered else '- '
        text: str = self._get_inner_text(element, ' ')
        return f'{prefix}{text}\n'

    def _handle_table(self, element: Tag) -> str:
        """Converts an HTML table into a pipe-delimited plain text format."""
        table_text_parts: List[str] = []
        for row in element.find_all('tr'):
            # Only process cells that are Tag
            all_cells = cast(List[Any], row.find_all(['th', 'td']))  # type: ignore[reportUnknownVariableType]
            tag_cells = [cell for cell in all_cells if isinstance(cell, Tag)]
            cell_texts: List[str] = [self._get_inner_text(cell, ' ').replace('\n', ' ').strip() for cell in tag_cells]
            table_text_parts.append(' | '.join(cell_texts))

        table_text: str = '\n'.join(table_text_parts)
        return f'\n--- TABLE ---\n{table_text}\n--- END TABLE ---\n'

    def _handle_macro(self, element: Tag) -> str:
        """Handles Confluence-specific <ac:structured-macro> tags."""
        name_raw: Any = element.get('ac:name')
        macro_name: str = name_raw.lower() if isinstance(name_raw, str) else 'macro'
        body: Optional[Tag] = cast(
            Optional[Tag], element.find('ac:rich-text-body') or element.find('ac:plain-text-body')
        )

        if not body:
            return ''

        content: str = self._get_inner_text(body, ' ').strip()

        # Format known macros for better semantic meaning
        if macro_name == 'info':
            return f'\n[Note] {content}\n'
        if macro_name == 'warning':
            return f'\n[Warning] {content}\n'
        if macro_name == 'code':
            # Code blocks often have special formatting needs
            code_content: str = body.get_text()  # Preserve whitespace inside code blocks
            return f'\n--- CODE ---\n{code_content.strip()}\n--- END CODE ---\n'

        # Fallback for other macros
        return f'\n[{macro_name.upper()}] {content}\n'
